# è‡ªå®šä¹‰é€‚é…å™¨

MCPStore æä¾›å¼ºå¤§çš„é€‚é…å™¨ç³»ç»Ÿï¼Œè®©æ‚¨å¯ä»¥è½»æ¾é›†æˆå„ç§ AI æ¡†æ¶å’Œå·¥å…·åº“ï¼Œå®ç°æ— ç¼çš„å·¥å…·å…±äº«å’Œè°ƒç”¨ã€‚

## ğŸ¯ é€‚é…å™¨æ¦‚è¿°

é€‚é…å™¨æ˜¯ MCPStore ä¸å…¶ä»– AI æ¡†æ¶ä¹‹é—´çš„æ¡¥æ¢ï¼Œè´Ÿè´£ï¼š

- **æ ¼å¼è½¬æ¢**: å°† MCP å·¥å…·è½¬æ¢ä¸ºç›®æ ‡æ¡†æ¶çš„å·¥å…·æ ¼å¼
- **å‚æ•°æ˜ å°„**: å¤„ç†ä¸åŒæ¡†æ¶é—´çš„å‚æ•°å·®å¼‚
- **è°ƒç”¨ä»£ç†**: ä»£ç†å·¥å…·è°ƒç”¨å¹¶å¤„ç†ç»“æœ
- **é”™è¯¯å¤„ç†**: ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œå¼‚å¸¸è½¬æ¢

## ğŸ—ï¸ é€‚é…å™¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MCPStore æ ¸å¿ƒ                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              é€‚é…å™¨å±‚ (Adapter Layer)                   â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚ â”‚
â”‚  â”‚  â”‚ LangChain   â”‚ â”‚   CrewAI    â”‚ â”‚  AutoGen    â”‚      â”‚ â”‚
â”‚  â”‚  â”‚  Adapter    â”‚ â”‚  Adapter    â”‚ â”‚  Adapter    â”‚      â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚ â”‚
â”‚  â”‚  â”‚   Haystack  â”‚ â”‚   Custom    â”‚ â”‚   Future    â”‚      â”‚ â”‚
â”‚  â”‚  â”‚   Adapter   â”‚ â”‚   Adapter   â”‚ â”‚   Adapter   â”‚      â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚               MCPStore å·¥å…·å±‚                           â”‚ â”‚
â”‚  â”‚        list_tools() / call_tool()                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ åŸºç¡€é€‚é…å™¨æ¥å£

### é€‚é…å™¨è®¾è®¡æ¨¡å¼

MCPStore çš„é€‚é…å™¨é‡‡ç”¨ç»„åˆæ¨¡å¼è®¾è®¡ï¼Œé€šè¿‡åŒ…è£… MCPStoreContext æ¥æä¾›ç‰¹å®šæ¡†æ¶çš„æ¥å£ï¼š

```python
from typing import List, Any, Dict
from mcpstore.core.context import MCPStoreContext

class CustomAdapter:
    """
    è‡ªå®šä¹‰é€‚é…å™¨ç¤ºä¾‹

    é€‚é…å™¨é€šè¿‡ç»„åˆ MCPStoreContext æ¥æä¾›ç‰¹å®šæ¡†æ¶çš„æ¥å£
    """

    def __init__(self, context: MCPStoreContext):
        """
        åˆå§‹åŒ–é€‚é…å™¨

        Args:
            context: MCPStoreContext å®ä¾‹
        """
        self.context = context
        self._tool_cache = {}
        self._framework_tools = []

    def convert_tools(self) -> List[Any]:
        """
        è½¬æ¢å·¥å…·ä¸ºç›®æ ‡æ¡†æ¶æ ¼å¼

        Returns:
            ç›®æ ‡æ¡†æ¶çš„å·¥å…·å¯¹è±¡åˆ—è¡¨
        """
        mcp_tools = self.context.list_tools()
        framework_tools = []

        for tool in mcp_tools:
            framework_tool = self.create_tool_wrapper(tool)
            framework_tools.append(framework_tool)

        return framework_tools

    def create_tool_wrapper(self, tool_info) -> Any:
        """
        ä¸ºå•ä¸ªå·¥å…·åˆ›å»ºåŒ…è£…å™¨

        Args:
            tool_info: MCP å·¥å…·ä¿¡æ¯

        Returns:
            ç›®æ ‡æ¡†æ¶çš„å·¥å…·å¯¹è±¡
        """
        # å®ç°å…·ä½“çš„å·¥å…·åŒ…è£…é€»è¾‘
        def tool_function(**kwargs):
            return self.context.call_tool(tool_info.name, kwargs)

        # è¿”å›é€‚åˆç›®æ ‡æ¡†æ¶çš„å·¥å…·å¯¹è±¡
        return {
            'name': tool_info.name,
            'description': tool_info.description,
            'function': tool_function,
            'schema': tool_info.input_schema
        }

    def get_tools(self):
        """è·å– MCP å·¥å…·åˆ—è¡¨"""
        return self.context.list_tools()

    def call_mcp_tool(self, tool_name: str, args: Dict[str, Any]) -> Any:
        """è°ƒç”¨ MCP å·¥å…·"""
        return self.context.call_tool(tool_name, args)

    def refresh_tools(self):
        """åˆ·æ–°å·¥å…·ç¼“å­˜"""
        self._tool_cache.clear()
        self._framework_tools = self.convert_tools()
```

## ğŸš€ LangChain é€‚é…å™¨å®ç°

MCPStore å†…ç½®çš„ LangChain é€‚é…å™¨æ˜¯æœ€å®Œæ•´çš„å®ç°ç¤ºä¾‹ï¼š

```python
from typing import List, Type, Any, Dict
from pydantic import BaseModel, Field, create_model
from langchain_core.tools import BaseTool
from mcpstore.adapters.base import AdapterBase

class LangChainAdapter(AdapterBase):
    """LangChain é€‚é…å™¨"""
    
    def convert_tools(self) -> List[BaseTool]:
        """è½¬æ¢ä¸º LangChain Tool å¯¹è±¡"""
        tools = self.get_tools()
        langchain_tools = []
        
        for tool_info in tools:
            try:
                langchain_tool = self.create_tool_wrapper(tool_info)
                langchain_tools.append(langchain_tool)
            except Exception as e:
                print(f"âš ï¸ Failed to convert tool {tool_info.name}: {e}")
                continue
        
        return langchain_tools
    
    def create_tool_wrapper(self, tool_info) -> BaseTool:
        """åˆ›å»º LangChain Tool åŒ…è£…å™¨"""
        # å¢å¼ºå·¥å…·æè¿°
        enhanced_description = self._enhance_description(tool_info)
        
        # è½¬æ¢å‚æ•° Schema
        args_schema = self._convert_schema(tool_info.inputSchema)
        
        # åˆ›å»ºåŠ¨æ€ Tool ç±»
        class MCPTool(BaseTool):
            name: str = tool_info.name
            description: str = enhanced_description
            args_schema: Type[BaseModel] = args_schema
            
            def _run(self, **kwargs) -> str:
                """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
                try:
                    result = self.call_mcp_tool(tool_info.name, kwargs)
                    return self._format_result(result)
                except Exception as e:
                    return f"Error calling tool {tool_info.name}: {str(e)}"
            
            async def _arun(self, **kwargs) -> str:
                """å¼‚æ­¥æ‰§è¡Œå·¥å…·è°ƒç”¨"""
                try:
                    result = await self.context.call_tool_async(tool_info.name, kwargs)
                    return self._format_result(result)
                except Exception as e:
                    return f"Error calling tool {tool_info.name}: {str(e)}"
            
            def _format_result(self, result: Any) -> str:
                """æ ¼å¼åŒ–ç»“æœä¸ºå­—ç¬¦ä¸²"""
                if isinstance(result, str):
                    return result
                elif isinstance(result, (dict, list)):
                    import json
                    return json.dumps(result, ensure_ascii=False, indent=2)
                else:
                    return str(result)
        
        return MCPTool()
    
    def _enhance_description(self, tool_info) -> str:
        """å¢å¼ºå·¥å…·æè¿°"""
        description = tool_info.description
        
        if tool_info.inputSchema and 'properties' in tool_info.inputSchema:
            description += "\n\nå‚æ•°è¯´æ˜:"
            for param_name, param_info in tool_info.inputSchema['properties'].items():
                param_desc = param_info.get('description', 'æ— æè¿°')
                param_type = param_info.get('type', 'string')
                description += f"\n- {param_name} ({param_type}): {param_desc}"
        
        return description
    
    def _convert_schema(self, input_schema: Optional[Dict]) -> Type[BaseModel]:
        """è½¬æ¢ JSON Schema ä¸º Pydantic æ¨¡å‹"""
        if not input_schema or 'properties' not in input_schema:
            return BaseModel
        
        fields = {}
        properties = input_schema['properties']
        required = input_schema.get('required', [])
        
        for field_name, field_schema in properties.items():
            field_type = self._json_type_to_python(field_schema.get('type', 'string'))
            field_description = field_schema.get('description', '')
            is_required = field_name in required
            
            if is_required:
                fields[field_name] = (field_type, Field(description=field_description))
            else:
                fields[field_name] = (Optional[field_type], Field(None, description=field_description))
        
        return create_model('ToolArgs', **fields)
    
    def _json_type_to_python(self, json_type: str) -> Type:
        """JSON ç±»å‹è½¬ Python ç±»å‹"""
        type_mapping = {
            'string': str,
            'integer': int,
            'number': float,
            'boolean': bool,
            'array': list,
            'object': dict
        }
        return type_mapping.get(json_type, str)

# ä½¿ç”¨ç¤ºä¾‹
def get_langchain_tools(store):
    """è·å– LangChain å·¥å…·"""
    context = store.for_store()
    adapter = LangChainAdapter(context)
    return adapter.convert_tools()
```

## ğŸ¤– CrewAI é€‚é…å™¨å®ç°

```python
from typing import List, Any, Dict, Optional
from mcpstore.adapters.base import AdapterBase

class CrewAIAdapter(AdapterBase):
    """CrewAI é€‚é…å™¨"""
    
    def convert_tools(self) -> List[Any]:
        """è½¬æ¢ä¸º CrewAI Tool å¯¹è±¡"""
        try:
            from crewai_tools import BaseTool
        except ImportError:
            raise ImportError("CrewAI not installed. Run: pip install crewai")
        
        tools = self.get_tools()
        crewai_tools = []
        
        for tool_info in tools:
            try:
                crewai_tool = self.create_tool_wrapper(tool_info)
                crewai_tools.append(crewai_tool)
            except Exception as e:
                print(f"âš ï¸ Failed to convert tool {tool_info.name}: {e}")
                continue
        
        return crewai_tools
    
    def create_tool_wrapper(self, tool_info) -> Any:
        """åˆ›å»º CrewAI Tool åŒ…è£…å™¨"""
        from crewai_tools import BaseTool
        from pydantic import BaseModel, Field
        
        # åˆ›å»ºå‚æ•°æ¨¡å‹
        args_schema = self._create_args_schema(tool_info.inputSchema)
        
        class MCPCrewTool(BaseTool):
            name: str = tool_info.name
            description: str = self._enhance_description(tool_info)
            args_schema: type = args_schema
            
            def _run(self, **kwargs) -> str:
                """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
                try:
                    result = self.call_mcp_tool(tool_info.name, kwargs)
                    return self._format_result(result)
                except Exception as e:
                    return f"Error: {str(e)}"
            
            def _format_result(self, result: Any) -> str:
                """æ ¼å¼åŒ–ç»“æœ"""
                if isinstance(result, str):
                    return result
                elif isinstance(result, (dict, list)):
                    import json
                    return json.dumps(result, ensure_ascii=False, indent=2)
                else:
                    return str(result)
        
        return MCPCrewTool()
    
    def _create_args_schema(self, input_schema: Optional[Dict]) -> type:
        """åˆ›å»ºå‚æ•° Schema"""
        from pydantic import BaseModel, Field, create_model
        
        if not input_schema or 'properties' not in input_schema:
            return BaseModel
        
        fields = {}
        properties = input_schema['properties']
        required = input_schema.get('required', [])
        
        for field_name, field_schema in properties.items():
            field_type = self._json_type_to_python(field_schema.get('type', 'string'))
            field_description = field_schema.get('description', '')
            is_required = field_name in required
            
            if is_required:
                fields[field_name] = (field_type, Field(description=field_description))
            else:
                fields[field_name] = (Optional[field_type], Field(None, description=field_description))
        
        return create_model('CrewToolArgs', **fields)
    
    def _enhance_description(self, tool_info) -> str:
        """å¢å¼ºå·¥å…·æè¿°"""
        description = tool_info.description
        
        if tool_info.inputSchema and 'properties' in tool_info.inputSchema:
            description += "\n\nParameters:"
            for param_name, param_info in tool_info.inputSchema['properties'].items():
                param_desc = param_info.get('description', 'No description')
                param_type = param_info.get('type', 'string')
                description += f"\n- {param_name} ({param_type}): {param_desc}"
        
        return description
    
    def _json_type_to_python(self, json_type: str) -> type:
        """JSON ç±»å‹è½¬ Python ç±»å‹"""
        type_mapping = {
            'string': str,
            'integer': int,
            'number': float,
            'boolean': bool,
            'array': list,
            'object': dict
        }
        return type_mapping.get(json_type, str)

# ä½¿ç”¨ç¤ºä¾‹
def setup_crewai_agent(store):
    """è®¾ç½® CrewAI Agent"""
    from crewai import Agent, Task, Crew
    
    # è·å–å·¥å…·
    context = store.for_store()
    adapter = CrewAIAdapter(context)
    tools = adapter.convert_tools()
    
    # åˆ›å»º Agent
    agent = Agent(
        role='Research Assistant',
        goal='Help with research and analysis tasks',
        backstory='An AI assistant with access to various MCP tools',
        tools=tools,
        verbose=True
    )
    
    return agent
```

## ğŸ”§ AutoGen é€‚é…å™¨å®ç°

```python
from typing import List, Any, Dict, Callable
from mcpstore.adapters.base import AdapterBase

class AutoGenAdapter(AdapterBase):
    """AutoGen é€‚é…å™¨"""
    
    def convert_tools(self) -> List[Dict[str, Any]]:
        """è½¬æ¢ä¸º AutoGen å·¥å…·æ ¼å¼"""
        tools = self.get_tools()
        autogen_tools = []
        
        for tool_info in tools:
            try:
                autogen_tool = self.create_tool_wrapper(tool_info)
                autogen_tools.append(autogen_tool)
            except Exception as e:
                print(f"âš ï¸ Failed to convert tool {tool_info.name}: {e}")
                continue
        
        return autogen_tools
    
    def create_tool_wrapper(self, tool_info) -> Dict[str, Any]:
        """åˆ›å»º AutoGen å·¥å…·åŒ…è£…å™¨"""
        
        def tool_function(**kwargs) -> str:
            """å·¥å…·æ‰§è¡Œå‡½æ•°"""
            try:
                result = self.call_mcp_tool(tool_info.name, kwargs)
                return self._format_result(result)
            except Exception as e:
                return f"Error calling {tool_info.name}: {str(e)}"
        
        # æ„é€  AutoGen å·¥å…·æè¿°
        tool_spec = {
            "type": "function",
            "function": {
                "name": tool_info.name,
                "description": tool_info.description,
                "parameters": self._convert_schema_to_autogen(tool_info.inputSchema)
            }
        }
        
        return {
            "spec": tool_spec,
            "function": tool_function
        }
    
    def _convert_schema_to_autogen(self, input_schema: Optional[Dict]) -> Dict[str, Any]:
        """è½¬æ¢ Schema ä¸º AutoGen æ ¼å¼"""
        if not input_schema:
            return {
                "type": "object",
                "properties": {},
                "required": []
            }
        
        # AutoGen ä½¿ç”¨ OpenAI å‡½æ•°è°ƒç”¨æ ¼å¼
        return {
            "type": "object",
            "properties": input_schema.get("properties", {}),
            "required": input_schema.get("required", [])
        }
    
    def _format_result(self, result: Any) -> str:
        """æ ¼å¼åŒ–ç»“æœ"""
        if isinstance(result, str):
            return result
        elif isinstance(result, (dict, list)):
            import json
            return json.dumps(result, ensure_ascii=False, indent=2)
        else:
            return str(result)
    
    def register_tools_with_agent(self, agent) -> None:
        """å°†å·¥å…·æ³¨å†Œåˆ° AutoGen Agent"""
        tools = self.convert_tools()
        
        for tool in tools:
            # æ³¨å†Œå‡½æ•°
            agent.register_function(
                function_map={tool["spec"]["function"]["name"]: tool["function"]}
            )

# ä½¿ç”¨ç¤ºä¾‹
def setup_autogen_agent(store):
    """è®¾ç½® AutoGen Agent"""
    try:
        from autogen import ConversableAgent
    except ImportError:
        raise ImportError("AutoGen not installed. Run: pip install pyautogen")
    
    # åˆ›å»º Agent
    agent = ConversableAgent(
        name="assistant",
        system_message="You are a helpful assistant with access to various tools.",
        llm_config={
            "config_list": [{"model": "gpt-4", "api_key": "your-api-key"}]
        }
    )
    
    # æ³¨å†Œ MCP å·¥å…·
    context = store.for_store()
    adapter = AutoGenAdapter(context)
    adapter.register_tools_with_agent(agent)
    
    return agent
```

## ğŸ¨ è‡ªå®šä¹‰é€‚é…å™¨å¼€å‘

### 1. ç®€å•å‡½æ•°å¼é€‚é…å™¨

```python
def create_simple_adapter(context):
    """åˆ›å»ºç®€å•çš„å‡½æ•°å¼é€‚é…å™¨"""
    
    def get_tool_functions() -> Dict[str, Callable]:
        """è·å–å·¥å…·å‡½æ•°å­—å…¸"""
        tools = context.list_tools()
        tool_functions = {}
        
        for tool_info in tools:
            def create_tool_func(tool_name):
                def tool_func(**kwargs):
                    return context.call_tool(tool_name, kwargs)
                return tool_func
            
            tool_functions[tool_info.name] = create_tool_func(tool_info.name)
        
        return tool_functions
    
    def get_tool_descriptions() -> Dict[str, str]:
        """è·å–å·¥å…·æè¿°å­—å…¸"""
        tools = context.list_tools()
        return {tool.name: tool.description for tool in tools}
    
    return {
        'functions': get_tool_functions(),
        'descriptions': get_tool_descriptions()
    }

# ä½¿ç”¨ç¤ºä¾‹
adapter = create_simple_adapter(store.for_store())
functions = adapter['functions']
descriptions = adapter['descriptions']

# è°ƒç”¨å·¥å…·
result = functions['weather_get_current'](city="åŒ—äº¬")
```

### 2. ç±»å‹å®‰å…¨é€‚é…å™¨

```python
from typing import TypeVar, Generic, Protocol
from dataclasses import dataclass

T = TypeVar('T')

class ToolProtocol(Protocol):
    """å·¥å…·åè®®å®šä¹‰"""
    name: str
    description: str
    
    def execute(self, **kwargs) -> Any:
        """æ‰§è¡Œå·¥å…·"""
        ...

@dataclass
class TypedTool:
    """ç±»å‹åŒ–å·¥å…·åŒ…è£…å™¨"""
    name: str
    description: str
    input_type: type
    output_type: type
    executor: Callable
    
    def execute(self, **kwargs) -> Any:
        """æ‰§è¡Œå·¥å…·å¹¶è¿›è¡Œç±»å‹æ£€æŸ¥"""
        # è¾“å…¥ç±»å‹éªŒè¯
        if self.input_type != Any:
            try:
                validated_input = self.input_type(**kwargs)
                kwargs = validated_input.dict()
            except Exception as e:
                raise ValueError(f"Input validation failed: {e}")
        
        # æ‰§è¡Œå·¥å…·
        result = self.executor(**kwargs)
        
        # è¾“å‡ºç±»å‹éªŒè¯
        if self.output_type != Any and not isinstance(result, self.output_type):
            try:
                result = self.output_type(result)
            except Exception:
                pass  # ç±»å‹è½¬æ¢å¤±è´¥æ—¶ä¿æŒåŸç»“æœ
        
        return result

class TypeSafeAdapter(AdapterBase):
    """ç±»å‹å®‰å…¨é€‚é…å™¨"""
    
    def convert_tools(self) -> List[TypedTool]:
        """è½¬æ¢ä¸ºç±»å‹å®‰å…¨å·¥å…·"""
        tools = self.get_tools()
        typed_tools = []
        
        for tool_info in tools:
            typed_tool = self.create_tool_wrapper(tool_info)
            typed_tools.append(typed_tool)
        
        return typed_tools
    
    def create_tool_wrapper(self, tool_info) -> TypedTool:
        """åˆ›å»ºç±»å‹åŒ–å·¥å…·åŒ…è£…å™¨"""
        input_type = self._create_input_type(tool_info.inputSchema)
        output_type = Any  # å¯ä»¥æ ¹æ®éœ€è¦æ¨æ–­è¾“å‡ºç±»å‹
        
        def executor(**kwargs):
            return self.call_mcp_tool(tool_info.name, kwargs)
        
        return TypedTool(
            name=tool_info.name,
            description=tool_info.description,
            input_type=input_type,
            output_type=output_type,
            executor=executor
        )
    
    def _create_input_type(self, input_schema: Optional[Dict]) -> type:
        """ä» Schema åˆ›å»ºè¾“å…¥ç±»å‹"""
        if not input_schema:
            return Any
        
        from pydantic import create_model
        
        fields = {}
        properties = input_schema.get('properties', {})
        required = input_schema.get('required', [])
        
        for field_name, field_schema in properties.items():
            field_type = self._json_type_to_python(field_schema.get('type', 'string'))
            is_required = field_name in required
            
            if is_required:
                fields[field_name] = (field_type, ...)
            else:
                fields[field_name] = (Optional[field_type], None)
        
        return create_model('InputModel', **fields)
```

## ğŸ”„ é€‚é…å™¨æ³¨å†Œå’Œä½¿ç”¨

### é€‚é…å™¨æ³¨å†Œç³»ç»Ÿ

```python
class AdapterRegistry:
    """é€‚é…å™¨æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self._adapters: Dict[str, type] = {}
    
    def register(self, name: str, adapter_class: type):
        """æ³¨å†Œé€‚é…å™¨"""
        self._adapters[name] = adapter_class
    
    def get(self, name: str) -> Optional[type]:
        """è·å–é€‚é…å™¨ç±»"""
        return self._adapters.get(name)
    
    def list_adapters(self) -> List[str]:
        """åˆ—å‡ºæ‰€æœ‰é€‚é…å™¨"""
        return list(self._adapters.keys())
    
    def create_adapter(self, name: str, context) -> Optional[AdapterBase]:
        """åˆ›å»ºé€‚é…å™¨å®ä¾‹"""
        adapter_class = self.get(name)
        if adapter_class:
            return adapter_class(context)
        return None

# å…¨å±€æ³¨å†Œè¡¨
adapter_registry = AdapterRegistry()

# æ³¨å†Œå†…ç½®é€‚é…å™¨
adapter_registry.register('langchain', LangChainAdapter)
adapter_registry.register('crewai', CrewAIAdapter)
adapter_registry.register('autogen', AutoGenAdapter)

# ä¾¿æ·å‡½æ•°
def register_adapter(name: str, adapter_class: type):
    """æ³¨å†Œé€‚é…å™¨"""
    adapter_registry.register(name, adapter_class)

def get_adapter(name: str, context) -> Optional[AdapterBase]:
    """è·å–é€‚é…å™¨å®ä¾‹"""
    return adapter_registry.create_adapter(name, context)
```

### ç»Ÿä¸€é€‚é…å™¨æ¥å£

```python
class MCPStoreContext:
    """æ‰©å±• MCPStoreContext ä»¥æ”¯æŒé€‚é…å™¨"""
    
    def for_framework(self, framework: str) -> Optional[AdapterBase]:
        """è·å–æŒ‡å®šæ¡†æ¶çš„é€‚é…å™¨"""
        return get_adapter(framework, self)
    
    def for_langchain(self) -> LangChainAdapter:
        """è·å– LangChain é€‚é…å™¨ï¼ˆå‘åå…¼å®¹ï¼‰"""
        return LangChainAdapter(self)
    
    def for_crewai(self) -> CrewAIAdapter:
        """è·å– CrewAI é€‚é…å™¨"""
        return CrewAIAdapter(self)
    
    def for_autogen(self) -> AutoGenAdapter:
        """è·å– AutoGen é€‚é…å™¨"""
        return AutoGenAdapter(self)

# ä½¿ç”¨ç¤ºä¾‹
store = MCPStore.setup_store()

# ç»Ÿä¸€æ¥å£
langchain_tools = store.for_store().for_framework('langchain').convert_tools()
crewai_tools = store.for_store().for_framework('crewai').convert_tools()

# ä¸“ç”¨æ¥å£
langchain_tools = store.for_store().for_langchain().list_tools()
crewai_agent = setup_crewai_agent(store)
```

## ğŸ“Š é€‚é…å™¨æ€§èƒ½ä¼˜åŒ–

### 1. å·¥å…·ç¼“å­˜

```python
class CachedAdapter(AdapterBase):
    """å¸¦ç¼“å­˜çš„é€‚é…å™¨"""
    
    def __init__(self, context):
        super().__init__(context)
        self._converted_tools_cache = None
        self._cache_timestamp = None
    
    def convert_tools(self) -> List[Any]:
        """å¸¦ç¼“å­˜çš„å·¥å…·è½¬æ¢"""
        current_time = time.time()
        
        # æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ5åˆ†é’Ÿè¿‡æœŸï¼‰
        if (self._converted_tools_cache is not None and 
            self._cache_timestamp is not None and
            current_time - self._cache_timestamp < 300):
            return self._converted_tools_cache
        
        # é‡æ–°è½¬æ¢å·¥å…·
        tools = super().convert_tools()
        self._converted_tools_cache = tools
        self._cache_timestamp = current_time
        
        return tools
    
    def refresh_cache(self):
        """æ‰‹åŠ¨åˆ·æ–°ç¼“å­˜"""
        self._converted_tools_cache = None
        self._cache_timestamp = None
```

### 2. å»¶è¿ŸåŠ è½½

```python
class LazyAdapter(AdapterBase):
    """å»¶è¿ŸåŠ è½½é€‚é…å™¨"""
    
    def __init__(self, context):
        super().__init__(context)
        self._tool_wrappers = {}
    
    def convert_tools(self) -> List[Any]:
        """å»¶è¿Ÿåˆ›å»ºå·¥å…·åŒ…è£…å™¨"""
        tools = self.get_tools()
        lazy_tools = []
        
        for tool_info in tools:
            lazy_tool = self._create_lazy_wrapper(tool_info)
            lazy_tools.append(lazy_tool)
        
        return lazy_tools
    
    def _create_lazy_wrapper(self, tool_info):
        """åˆ›å»ºå»¶è¿ŸåŒ…è£…å™¨"""
        class LazyTool:
            def __init__(self, adapter, tool_info):
                self.adapter = adapter
                self.tool_info = tool_info
                self._wrapper = None
            
            def __getattr__(self, name):
                if self._wrapper is None:
                    self._wrapper = self.adapter.create_tool_wrapper(self.tool_info)
                return getattr(self._wrapper, name)
        
        return LazyTool(self, tool_info)
```

## ğŸ§ª é€‚é…å™¨æµ‹è¯•

### æµ‹è¯•æ¡†æ¶

```python
import pytest
from unittest.mock import Mock, patch
from mcpstore.adapters.base import AdapterBase

class TestCustomAdapter:
    """è‡ªå®šä¹‰é€‚é…å™¨æµ‹è¯•"""
    
    def setup_method(self):
        """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
        self.mock_context = Mock()
        self.mock_context.list_tools.return_value = [
            Mock(
                name="test_tool",
                description="Test tool description",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "param1": {"type": "string", "description": "Parameter 1"}
                    },
                    "required": ["param1"]
                }
            )
        ]
        self.mock_context.call_tool.return_value = "test result"
        
        self.adapter = CustomAdapter(self.mock_context)
    
    def test_convert_tools(self):
        """æµ‹è¯•å·¥å…·è½¬æ¢"""
        tools = self.adapter.convert_tools()
        
        assert len(tools) == 1
        assert tools[0].name == "test_tool"
        assert "Test tool description" in tools[0].description
    
    def test_tool_execution(self):
        """æµ‹è¯•å·¥å…·æ‰§è¡Œ"""
        tools = self.adapter.convert_tools()
        tool = tools[0]
        
        result = tool.execute(param1="test value")
        
        assert result == "test result"
        self.mock_context.call_tool.assert_called_once_with(
            "test_tool", {"param1": "test value"}
        )
    
    def test_error_handling(self):
        """æµ‹è¯•é”™è¯¯å¤„ç†"""
        self.mock_context.call_tool.side_effect = Exception("Test error")
        
        tools = self.adapter.convert_tools()
        tool = tools[0]
        
        result = tool.execute(param1="test value")
        
        assert "Error" in result
```

## ğŸ“š æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```python
class RobustAdapter(AdapterBase):
    """å¥å£®çš„é€‚é…å™¨å®ç°"""
    
    def create_tool_wrapper(self, tool_info):
        """åˆ›å»ºå¥å£®çš„å·¥å…·åŒ…è£…å™¨"""
        
        def safe_execute(**kwargs):
            try:
                # å‚æ•°éªŒè¯
                validated_args = self._validate_args(tool_info, kwargs)
                
                # è°ƒç”¨å·¥å…·
                result = self.call_mcp_tool(tool_info.name, validated_args)
                
                # ç»“æœéªŒè¯
                return self._validate_result(result)
                
            except ValidationError as e:
                return f"å‚æ•°éªŒè¯å¤±è´¥: {e}"
            except ToolCallError as e:
                return f"å·¥å…·è°ƒç”¨å¤±è´¥: {e}"
            except Exception as e:
                return f"æœªçŸ¥é”™è¯¯: {e}"
        
        return safe_execute
```

### 2. æ€§èƒ½ç›‘æ§

```python
import time
from functools import wraps

def monitor_performance(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            duration = time.time() - start_time
            print(f"âœ… {func.__name__} completed in {duration:.3f}s")
            return result
        except Exception as e:
            duration = time.time() - start_time
            print(f"âŒ {func.__name__} failed in {duration:.3f}s: {e}")
            raise
    return wrapper

class MonitoredAdapter(AdapterBase):
    """å¸¦æ€§èƒ½ç›‘æ§çš„é€‚é…å™¨"""
    
    @monitor_performance
    def convert_tools(self):
        return super().convert_tools()
    
    @monitor_performance
    def create_tool_wrapper(self, tool_info):
        return super().create_tool_wrapper(tool_info)
```

## ç›¸å…³æ–‡æ¡£

- [æ’ä»¶å¼€å‘](plugin-development.md) - æ’ä»¶ç³»ç»Ÿè¯¦è§£
- [æ ¸å¿ƒæ¦‚å¿µ](concepts.md) - ç†è§£é€‚é…å™¨æ¶æ„
- [LangChain é›†æˆ](../tools/langchain/as-langchain-tools.md) - å†…ç½®é€‚é…å™¨ä½¿ç”¨

## ä¸‹ä¸€æ­¥

- å­¦ä¹  [æœ€ä½³å®è·µæŒ‡å—](best-practices.md)
- äº†è§£ [æ’ä»¶å¼€å‘æ–¹æ³•](plugin-development.md)
- æŸ¥çœ‹ [API å‚è€ƒæ–‡æ¡£](../api-reference/mcpstore-class.md)
