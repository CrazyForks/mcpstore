# 会话执行技术手册

> 面向工程师的实现说明：当前会话机制如何工作、FastMCP 的会话是怎样的、两者如何结合；涉及的类/函数/方法与关键调用链路一一说明。

---

## 1. 背景与目标

- 目标：在多次工具调用之间保持“服务端状态”（例如浏览器打开的页面、登录态、连接上下文），避免每次调用都新建/关闭连接造成的状态丢失与性能浪费。
- 结论：MCPStore 通过“会话（Session）→ 持久化 FastMCP Client → 执行时按会话路由”的架构，实现了与 FastMCP 原生会话机制一致的状态保持，并扩展了 Store/Agent 双层隔离与 LangChain 隐式会话路由能力。

---

## 2. FastMCP 的会话原理（参考）

- 服务器端（fastmcp-server）会为每个“连接/请求上下文”维护 session 概念，session_id 可来自服务器内部持有的上下文或 HTTP 头（如 `mcp-session-id`）。
- 只要客户端保持同一条连接或在后续请求中带上同一 session_id，服务端即可定位到先前的会话状态。

服务器端示例（节选）：
```python
# fastmcp-main/src/fastmcp/server/context.py
# 获取/生成 session_id（可从请求头或内部上下文衍生）
session_id = request.headers.get("mcp-session-id") or str(uuid4())
```

客户端侧（FastMCP Client）：
- 如果每次 `async with Client()` 后立即 `__aexit__` 关闭连接，则服务端“会话上下文”通常也会终止或无法复用。
- 要保持状态，需要在同一 Client/同一连接上进行多次调用，或在请求头/上下文中维持同一 session_id。

---

## 3. MCPStore 的会话机制（核心思路）

MCPStore 在 FastMCP 之上提供三层能力：
1) 会话对象与上下文管理（Session/SessionContext）
2) 执行期的会话路由（execute_tool_fastmcp/_execute_tool_with_session）
3) 生态适配（LangChain SessionAware 适配与隐式路由）

关键点：
- “会话”缓存并复用 FastMCP Client；不再在每次调用后关闭连接
- 执行调用时优先路由到“当前会话”的 Client，从而保持状态
- Store 与 Agent 采用 `agent_id` 维度的完整隔离

---

## 4. 关键对象与职责

### 4.1 AgentSession（基础会话容器）
- 位置：`src/mcpstore/core/agents/session_manager.py`
- 作用：保存某个 agent 维度下的一组持久化 FastMCP Client 与工具缓存。
- 关键字段：`services: Dict[str, Client]`、`tools: Dict[str, Dict]`、时间戳。

### 4.2 SessionManager（会话管理器）
- 位置：`src/mcpstore/core/agents/session_manager.py`
- 能力：
  - `create_session(agent_id)` 与 `get_session(agent_id)`（兼容旧式存储）
  - `create_named_session(agent_id, session_name, user_session_id=None)`：同一 agent 多会话；可注册用户自定义全局 ID 以跨上下文访问
  - `get_named_session(agent_id, session_name)`/`get_session_by_user_id(user_session_id)`：多入口检索
  - 超时清理：定期失活会话清除

### 4.3 Session（会话对象，面向用户的链式 API）
- 位置：`src/mcpstore/core/context/session.py`
- 能力（部分）：
  - 查询：`session_info()`、`list_services()`、`connection_status()`
  - 绑定服务：`bind_service(name)`（在会话中创建并缓存 Client）
  - 使用工具：`use_tool(name, args)`/`use_tool_async(...)`
  - 生命周期：`restart_session()`、`clear_cache()`、`close_session()`

### 4.4 SessionContext（上下文管理器）
- 位置：`src/mcpstore/core/context/session.py`
- 能力：`with store.for_store().with_session("id") as session:` 自动进入/退出会话作用域，并确保作用域内的工具调用默认路由到该会话（隐式路由）。

### 4.5 MCPStoreContext + SessionManagement Mixin（入口 API）
- 位置：`src/mcpstore/core/context/session_management.py`
- 能力（节选）：
  - `create_session(session_id, user_session_id=None)`：创建命名/共享会话
  - `find_session(session_id)` / `find_user_session(shared_id)`：获取现有会话
  - `with_session(session_id)`/`with_session_async(session_id)`：上下文管理器
  - `session_auto(session_id=..., default_timeout=..., auto_cleanup=..., session_prefix=...)`：自动会话管理
  - `for_langchain_with_session(session_id)` / `for_langchain_with_auto_session()`：返回绑定到会话的 LangChain 适配器

### 4.6 执行编排（ToolExecutionMixin）
- 位置：`src/mcpstore/core/orchestrator/tool_execution.py`
- 能力：
  - `execute_tool_fastmcp(service, tool, arguments, agent_id, timeout, ..., session_id)`：
    - 若带 `session_id` → 走 `_execute_tool_with_session(...)`
    - 否则 → 传统模式（会新建临时 Client，兼容旧用法）
  - `_execute_tool_with_session(session_id, service, tool, ...)`：内部核心，会话内获取/创建“持久化 Client”，在其上执行工具调用且不关闭连接。

### 4.7 注册表（ServiceRegistry）与隔离
- 位置：`src/mcpstore/core/registry/core_registry.py`
- 作用：所有缓存与映射均以 `agent_id` 为一级键，保障 Store/Agent 与 Agent/Agent 间隔离。

### 4.8 LangChain 适配层
- 位置：`src/mcpstore/adapters/langchain_adapter.py`
- `LangChainAdapter`：常规适配
- `SessionAwareLangChainAdapter`：会话感知版，创建“会话绑定的 LangChain 工具”，工具函数内部会将调用路由到目标会话。

### 4.9 隐式会话路由
- 位置：`src/mcpstore/core/context/base_context.py`、`src/mcpstore/core/context/tool_operations.py`
- 机制：在 `with_session(...)` 作用域内，`for_langchain().list_tools()` 自动返回会话绑定版适配器；直接 `use_tool()/call_tool_async()` 未显式传 `session_id` 时，也优先路由到当前激活会话。

---

## 5. 关键调用链与代码要点（节选）

### 5.1 执行核心：会话内复用 Client
```python
# src/mcpstore/core/orchestrator/tool_execution.py
async def _execute_tool_with_session(...):
    session = self.session_manager.get_named_session(effective_agent_id, session_id) or ...
    client = session.services.get(service_name) or await self._create_persistent_client(session, service_name)
    # 在持久连接上执行，不进入 async with，从而不关闭连接
    result = await executor.execute_tool(client=client, tool_name=tool_name, arguments=arguments, ...)
```

### 5.2 Session 对象：在会话中绑定与使用
```python
# src/mcpstore/core/context/session.py
class Session:
    def bind_service(self, service_name: str) -> 'Session':
        # 创建 FastMCP Client 并缓存至 self._agent_session.services
    def use_tool(self, tool_name: str, args: Dict[str, Any] = None, **kwargs) -> Any:
        # 将调用路由到该会话（最终走 _execute_tool_with_session）
```

### 5.3 上下文管理器：进入/退出时设置激活会话
```python
# src/mcpstore/core/context/session_management.py
def with_session(self, session_id: str) -> 'SessionContext':
    return SessionContext(self, session_id)
```
```python
# src/mcpstore/core/context/session.py
class SessionContext:
    def __enter__(self):
        # 记录并设置 _active_session，退出时还原；生命周期自动管理
```

### 5.4 自动会话：透明复用
```python
# src/mcpstore/core/context/session_management.py
def session_auto(self, session_id: Optional[str] = None, ...):
    self._auto_session_config = {...}
    if not self._auto_session:
        self._auto_session = self.get_session(session_id)
    self._auto_session_enabled = True
```

### 5.5 隐式会话路由
```python
# src/mcpstore/core/context/base_context.py
def for_langchain(self):
    # 若存在激活会话，返回 SessionAwareLangChainAdapter；否则返回常规适配
```
```python
# src/mcpstore/core/context/tool_operations.py
# 若存在 _active_session 且未显式传 session_id，则优先路由到该会话执行
```

### 5.6 LangChain 会话绑定工具
```python
# src/mcpstore/adapters/langchain_adapter.py
class SessionAwareLangChainAdapter(LangChainAdapter):
    async def list_tools_async(self) -> List[Tool]:
        # 构造“会话绑定”的工具，内部执行函数固定使用该会话
```

---

## 6. 如何“解决状态问题”

问题根因（重构前）：
- 每次工具调用都新建 `Client` 并 `async with client ...` 执行后立即关闭 → 服务端状态无法保持（例如浏览器回到 `about:blank`）。

解决方案（重构后）：
- 在“会话”中创建并缓存 `FastMCP Client`，执行时直接在该 Client 上调用，不再进入 `async with` 导致的立即关闭。
- 对于 `stdio` 传输，显式使用 `keep_alive=True` 维持子进程；对 SSE/http 流式传输，维持同一 Client/连接。
- 路由层（隐式/显式会话）确保所有相关调用都落在“同一会话”的同一 Client 上。

带来的效果：
- 多步工具调用之间状态连续（页面、登录态、上下文全部可复用）
- 性能显著提升（避免重复握手/进程启动）

---

## 7. Store 与 Agent 的隔离与命名映射

- 以 `agent_id` 为一级键的多张缓存表（sessions、tool_cache、service_to_client...）确保跨 Agent 隔离。
- Agent 本地服务名与全局存储服务名通过 `AgentServiceMapper`（后缀格式 `_byagent_{agent_id}`）映射，避免命名冲突，Agent 侧看到的始终是“本地名”。

---

## 8. API 与常用方法索引

会话创建/获取：
- `create_session(session_id, user_session_id=None)`
- `find_session(session_id)` / `find_user_session(shared_id)`

上下文管理：
- `with_session(session_id)` / `with_session_async(session_id)`

自动会话：
- `session_auto(session_id=None, default_timeout=7200, auto_cleanup=True, session_prefix='auto_')`
- `session_manual()`（关闭自动会话模式）

LangChain：
- `for_langchain()`（在 with_session/auto 模式下自动返回会话绑定工具）
- `for_langchain_with_session(session_id)` / `for_langchain_with_auto_session()`

执行（内部）：
- `execute_tool_fastmcp(..., session_id=...)` → `_execute_tool_with_session(...)`

Session 对象：
- `bind_service(name)` / `use_tool(name, args)` / `restart_session()` / `close_session()` 等

---

## 9. 端到端执行流程（示意）

以同步 with_session 为例：
1) `with store.for_store().with_session("browser_task") as s:` 进入作用域，设置 `_active_session`
2) `s.bind_service("browser")`：会话中创建 `FastMCP Client` 并缓存
3) `s.use_tool("browser_navigate", {...})`：执行路由 → `_execute_tool_with_session` → 使用会话缓存的 Client 调用 → 状态保持
4) 作用域退出：自动关闭或按策略清理，`_active_session` 恢复

自动会话模式：
1) `store.for_store().session_auto()`：创建/获取自动会话并开启自动路由
2) `store.for_store().use_tool(...)`：透明路由到自动会话的 Client，保持状态

LangChain：
1) 在 with/auto 作用域内 `tools = store.for_store().for_langchain().list_tools()`
2) 创建 Agent 并多次调用工具 → 工具函数内部固定路由到会话 → 状态保持

---

## 10. 典型注意点

- 在 `with_session` 作用域内“先获取工具再使用”，确保工具绑定的是当前会话。
- 服务端可用性：`add_service(...)` 后建议 `wait_service(name)` 确保服务启动完毕。
- 偶发清理报错如 `Failed to close current client ...` 多为无害的断线后清理失败，后续会自动重建连接。
- 并发/多协程：若高并发场景下复用同一 `MCPStoreContext`，建议将“激活会话状态”改为基于 `contextvars`（项目已有 `_active_session`，后续可增强线程/协程隔离）。

---

## 11. 附：与 FastMCP 的结合方式总结

- 保持一致：在一个“会话”中维持同一条 Client 连接（或同一 session_id），与 FastMCP 的 session 语义对齐。
- 更进一步：在 MCPStore 层面引入 Store/Agent 双层隔离与 LangChain 隐式路由，提升工程可用性与 DX。
- 本质：将 “状态保持的职责” 上移到 MCPStore 的 Session/路由层，从而避免每次调用都新建/关闭 FastMCP Client。

